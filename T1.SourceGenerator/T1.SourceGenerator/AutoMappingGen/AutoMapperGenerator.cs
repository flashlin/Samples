using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using T1.SourceGenerator.Attributes;
using T1.SourceGenerator.Utils;
using IndentStringBuilder = T1.SourceGenerator.Utils.IndentStringBuilder;

namespace T1.SourceGenerator.AutoMappingGen;

[Generator]
public class AutoMapperGenerator : ISourceGenerator
{
    private readonly EmbeddedSources _embedded = new EmbeddedSources(typeof(AutoMapperGenerator).Assembly);
    
    public void Initialize(GeneratorInitializationContext context)
    {
        //context.RegisterForSyntaxNotifications(() => new ClassSyntaxReceiver());
        context.RegisterForPostInitialization(i =>
        {
            i.AddSource("AutoMappingAttribute.g.cs", _embedded.LoadTemplateForEmitting("AutoMappingAttribute"));
        });
    }

    public void Execute(GeneratorExecutionContext context)
    {
        //var receiver = (ClassSyntaxReceiver)context.SyntaxReceiver!;
        //var options = (context.Compilation as CSharpCompilation)!.SyntaxTrees[0].Options as CSharpParseOptions; 
        //var compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(MappingAttributeText, Encoding.UTF8), options));
        //var compilation = context.Compilation.AddSyntaxTrees(autoMappingAttributeCompilation);

        var sourceBuilder = new IndentStringBuilder();
        
        sourceBuilder.WriteLine("//<auto-generated>");
        sourceBuilder.WriteLine("namespace T1.SourceGenerator");
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        sourceBuilder.WriteLine("public static class Mapper");
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        
        var compilation = context.Compilation;
        foreach (var type in compilation.GetAllTypes())
        {
            var fromClassFullName = type.TypeFullName;
            //var fromProperties = type.SyntaxNode.QueryPropertiesSyntaxes(compilation)
            //    .Where(x => x.Accessibility == Accessibility.Public && x.HasGetter)
            //    .ToList();
            var fromProperties = type.Properties
                .Where(x => x.Accessibility == AccessibilityInfo.Public && x.HasGetter)
                .ToList();

            var attrs = GetAutoMappingAttributes(type, compilation);
            foreach (var autoMappingAttr in attrs)
            {
                var toClassFullName = autoMappingAttr.ToTypeFullName;
                var toClassName = toClassFullName.GetName();
                var toMethodName = autoMappingAttr.ToMethodName ?? $"To{toClassName}";
                var toProperties = autoMappingAttr.ToTypeSyntax
                    .Properties
                    .Where(x => x.Accessibility == AccessibilityInfo.Public && x.HasSetter);
                var sameProperties = from tb1 in fromProperties
                    join tb2 in toProperties on new { tb1.Name, tb1.TypeFullName } equals new { tb2.Name, tb2.TypeFullName } 
                    select tb1.Name;

                sourceBuilder.WriteLine(
                    $@"public static {toClassFullName} {toMethodName}(this {fromClassFullName} source, Action<{fromClassFullName}, {toClassFullName}>? assignFn=null)");
                sourceBuilder.WriteLine("{");
                sourceBuilder.Indent++;
                sourceBuilder.WriteLine($"var target = new {toClassFullName}();");
                foreach (var propertyName in sameProperties)
                {
                    sourceBuilder.WriteLine($@"target.{propertyName} = source.{propertyName};");
                }
                sourceBuilder.WriteLine("assignFn?.Invoke(source, target);");
                sourceBuilder.WriteLine("return target;");
                sourceBuilder.Indent--;
                sourceBuilder.WriteLine("}");
            }
        }
        
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("}");
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("}");
        var code = sourceBuilder.ToString();
        context.AddSource("Mapper.g.cs", SourceText.From(code, Encoding.UTF8));

        //            var attrArguments = attr.ArgumentList!.Arguments;
        //            var fromTypeArgSyntax = attrArguments.First();
        //            var fromTypeArgSyntaxExpr = fromTypeArgSyntax.Expression.NormalizeWhitespace().ToFullString();

        //            var toTypeArgSyntax = attrArguments.ElementAt(1);
        //            var toTypeArgSyntaxExpr = toTypeArgSyntax.Expression.NormalizeWhitespace().ToFullString();

        //            var toClassName = GetContentInParentheses(toTypeArgSyntaxExpr);
        //            var toClassSyntax = allClasses.First(x => x.Identifier.ToString() == toClassName);
        //            var toClassModel = context.Compilation.GetSemanticModel(toClassSyntax.SyntaxTree);
        //            var toClassNamedTypeSymbol = ModelExtensions.GetDeclaredSymbol(toClassModel, toClassSyntax);
        //            var toClassFullName = toClassNamedTypeSymbol.OriginalDefinition.ToString();
    }

    private static IEnumerable<AutoMappingDeclarationInfo> GetAutoMappingAttributes(TypeSyntaxInfo type,
        Compilation compilation)
    {
        return type.Attributes
            .Where(x => x.TypeFullName == typeof(AutoMappingAttribute).FullName)
            .Select(x => new AutoMappingDeclarationInfo
            {
                ToTypeFullName = x.ConstructorArguments[0].ValueTypeFullName,
                ToMethodName = x.ConstructorArguments[1].Value as string,
                ToTypeSyntax = compilation.GetAllTypes()
                    .First(t => t.TypeFullName == x.ConstructorArguments[0].ValueTypeFullName)
            });
        //return type.SyntaxNode.AttributeLists.QueryAttributesSyntaxInfo(compilation)
        //    .Where(x => x.TypeFullName == typeof(AutoMappingAttribute).FullName)
        //    .Select(x => new AutoMappingDeclarationInfo
        //    {
        //        ToTypeFullName = x.ConstructorArguments[0].ValueTypeFullName,
        //        ToMethodName = x.ConstructorArguments[1].Value as string,
        //        ToTypeSyntax = compilation.GetAllTypes()
        //            .First(t => t.TypeFullName == x.ConstructorArguments[0].ValueTypeFullName).SyntaxNode
        //    });
    }
}