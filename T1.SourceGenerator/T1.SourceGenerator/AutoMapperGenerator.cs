using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using T1.SourceGenerator.Attributes;
using T1.SourceGenerator.Utils;
using IndentStringBuilder = T1.SourceGenerator.Utils.IndentStringBuilder;

namespace T1.SourceGenerator;

[Generator]
public class AutoMapperGenerator : ISourceGenerator
{
    private readonly EmbeddedSources _embedded = new EmbeddedSources(typeof(AutoMapperGenerator).Assembly);
    
    public void Initialize(GeneratorInitializationContext context)
    {
        //context.RegisterForSyntaxNotifications(() => new ClassSyntaxReceiver());
        context.RegisterForPostInitialization(i =>
        {
            i.AddSource("AutoMappingAttribute.g.cs", _embedded.LoadTemplateForEmitting("AutoMappingAttribute"));
        });
    }

    public void Execute(GeneratorExecutionContext context)
    {
        //var receiver = (ClassSyntaxReceiver)context.SyntaxReceiver!;
        //var options = (context.Compilation as CSharpCompilation)!.SyntaxTrees[0].Options as CSharpParseOptions; 
        //var compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(MappingAttributeText, Encoding.UTF8), options));
        //var compilation = context.Compilation.AddSyntaxTrees(autoMappingAttributeCompilation);

        var sourceBuilder = new IndentStringBuilder();
        
        sourceBuilder.WriteLine("//<auto-generated>");
        sourceBuilder.WriteLine("namespace T1.SourceGenerator");
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        sourceBuilder.WriteLine("public static class Mapper");
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        
        var compilation = context.Compilation;
        foreach (var type in compilation.GetAllTypes())
        {
            var fromClassFullName = type.TypeFullName;
            var fromProperties = type.SyntaxNode.GetPropertiesSyntaxList(compilation)
                .Where(x => x.Accessibility == Accessibility.Public && x.HasGetter)
                .ToList();

            var attrs = GetAutoMappingAttributes(type, compilation);
            foreach (var autoMappingAttr in attrs)
            {
                var toClassFullName = autoMappingAttr.ToTypeFullName;
                var toClassName = GetName(toClassFullName);
                var toProperties = autoMappingAttr.ToTypeSyntax.GetPropertiesSyntaxList(compilation)
                    .Where(x => x.Accessibility == Accessibility.Public && x.HasSetter);
                var sameProperties = from tb1 in fromProperties
                    join tb2 in toProperties on tb1.Name equals tb2.Name
                    select tb1.Name;

                sourceBuilder.WriteLine(
                    $@"public static {toClassFullName} To{toClassName}(this {fromClassFullName} source)");
                sourceBuilder.WriteLine("{");
                sourceBuilder.Indent++;
                sourceBuilder.WriteLine($"var target = new {toClassFullName}();");
                foreach (var propertyName in sameProperties)
                {
                    sourceBuilder.WriteLine($@"target.{propertyName} = source.{propertyName};");
                }
                sourceBuilder.WriteLine("return target;");
                sourceBuilder.Indent--;
                sourceBuilder.WriteLine("}");
            }
        }
        
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("}");
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("}");
        var code = sourceBuilder.ToString();
        context.AddSource("Mapper.g.cs", SourceText.From(code, Encoding.UTF8));

        //            var attrArguments = attr.ArgumentList!.Arguments;
        //            var fromTypeArgSyntax = attrArguments.First();
        //            var fromTypeArgSyntaxExpr = fromTypeArgSyntax.Expression.NormalizeWhitespace().ToFullString();

        //            var toTypeArgSyntax = attrArguments.ElementAt(1);
        //            var toTypeArgSyntaxExpr = toTypeArgSyntax.Expression.NormalizeWhitespace().ToFullString();

        //            var toClassName = GetContentInParentheses(toTypeArgSyntaxExpr);
        //            var toClassSyntax = allClasses.First(x => x.Identifier.ToString() == toClassName);
        //            var toClassModel = context.Compilation.GetSemanticModel(toClassSyntax.SyntaxTree);
        //            var toClassNamedTypeSymbol = ModelExtensions.GetDeclaredSymbol(toClassModel, toClassSyntax);
        //            var toClassFullName = toClassNamedTypeSymbol.OriginalDefinition.ToString();
    }

    private string GetName(string fullname)
    {
        var idx = fullname.LastIndexOf(".", StringComparison.Ordinal);
        if(idx == -1)
        {
            return fullname;
        }

        return fullname.Substring(idx + 1);
    }

    private static IEnumerable<AutoMappingDeclarationInfo> GetAutoMappingAttributes(TypeSyntaxInfo type,
        Compilation compilation)
    {
        return type.SyntaxNode.GetAttributesSyntaxInfo(compilation)
            .Where(x => x.TypeFullName == typeof(AutoMappingAttribute).FullName)
            .Select(x => new AutoMappingDeclarationInfo
            {
                ToTypeFullName = x.ConstructorArguments[0].ValueTypeFullName,
                ToTypeSyntax = compilation.GetAllTypes()
                    .First(t => t.TypeFullName == x.ConstructorArguments[0].ValueTypeFullName).SyntaxNode
            });
    }
}