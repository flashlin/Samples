using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using T1.SourceGenerator.Attributes;
using T1.SourceGenerator.Utils;

namespace T1.SourceGenerator;

[Generator]
public class AutoMapperGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        //context.RegisterForSyntaxNotifications(() => new ClassSyntaxReceiver());
        context.RegisterForPostInitialization(i =>
        {
            i.AddSource("AutoMappingAttribute.g.cs", EmbeddedSources.AutoMappingAttributeSource);
        });
    }

    public void Execute(GeneratorExecutionContext context)
    {
        //var receiver = (ClassSyntaxReceiver)context.SyntaxReceiver!;
        //var options = (context.Compilation as CSharpCompilation)!.SyntaxTrees[0].Options as CSharpParseOptions; 
        //var compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(MappingAttributeText, Encoding.UTF8), options));
        //var compilation = context.Compilation.AddSyntaxTrees(autoMappingAttributeCompilation);
        
        var sourceBuilder = new StringBuilder(@"
            //<auto-generated>
            namespace T1.SourceGenerator
            {
                public static class Mapper
                {");
        
        var compilation = context.Compilation;
        foreach (var type in compilation.GetAllTypes())
        {
            var fromClassFullName = type.TypeFullName;
            var fromProperties = type.SyntaxNode.GetPropertiesSyntaxList(compilation)
                .Where(x => x.Accessibility == Accessibility.Public && x.HasGetter)
                .ToList();

            var attrs = GetAutoMappingAttributes(type, compilation);
            foreach (var autoMappingAttr in attrs)
            {
                var toClassFullName = autoMappingAttr.ToTypeFullName;
                var toClassName = GetName(toClassFullName);
                var toProperties = autoMappingAttr.ToTypeSyntax.GetPropertiesSyntaxList(compilation)
                    .Where(x => x.Accessibility == Accessibility.Public && x.HasSetter);
                var sameProperties = from tb1 in fromProperties
                    join tb2 in toProperties on tb1.Name equals tb2.Name
                    select tb1.Name;

                sourceBuilder.AppendLine(
                    $@"public static {toClassFullName} To{toClassName}(this {fromClassFullName} source)");
                sourceBuilder.AppendLine("{");
                sourceBuilder.AppendLine($"var target = new {toClassFullName}();");
                foreach (var propertyName in sameProperties)
                {
                    sourceBuilder.AppendLine($@"target.{propertyName} = source.{propertyName};");
                }
                sourceBuilder.AppendLine("return target;");
                sourceBuilder.AppendLine("}");
            }
        }
        sourceBuilder.AppendLine("\t}");
        sourceBuilder.AppendLine("}");
        var code = sourceBuilder.ToString();
        context.AddSource("Mapper.g.cs", SourceText.From(code, Encoding.UTF8));

        //            var attrArguments = attr.ArgumentList!.Arguments;
        //            var fromTypeArgSyntax = attrArguments.First();
        //            var fromTypeArgSyntaxExpr = fromTypeArgSyntax.Expression.NormalizeWhitespace().ToFullString();

        //            var toTypeArgSyntax = attrArguments.ElementAt(1);
        //            var toTypeArgSyntaxExpr = toTypeArgSyntax.Expression.NormalizeWhitespace().ToFullString();

        //            var fromClassName = GetContentInParentheses(fromTypeArgSyntaxExpr);
        //            var fromClassSyntax = allClasses.First(x => x.Identifier.ToString() == fromClassName);
        //            var fromClassModel = context.Compilation.GetSemanticModel(fromClassSyntax.SyntaxTree);
        //            var fromClassNamedTypeSymbol = ModelExtensions.GetDeclaredSymbol(fromClassModel, fromClassSyntax);
        //            var fromClassFullName = fromClassNamedTypeSymbol.OriginalDefinition.ToString();

        //            var toClassName = GetContentInParentheses(toTypeArgSyntaxExpr);
        //            var toClassSyntax = allClasses.First(x => x.Identifier.ToString() == toClassName);
        //            var toClassModel = context.Compilation.GetSemanticModel(toClassSyntax.SyntaxTree);
        //            var toClassNamedTypeSymbol = ModelExtensions.GetDeclaredSymbol(toClassModel, toClassSyntax);
        //            var toClassFullName = toClassNamedTypeSymbol.OriginalDefinition.ToString();
    }

    private string GetName(string fullname)
    {
        var idx = fullname.LastIndexOf(".", StringComparison.Ordinal);
        if(idx == -1)
        {
            return fullname;
        }

        return fullname.Substring(idx + 1);
    }

    private static IEnumerable<AutoMappingDeclarationInfo> GetAutoMappingAttributes(TypeSyntaxInfo type,
        Compilation compilation)
    {
        return type.SyntaxNode.GetAttributesSyntaxInfo(compilation)
            .Where(x => x.TypeFullName == typeof(AutoMappingAttribute).FullName)
            .Select(x => new AutoMappingDeclarationInfo
            {
                ToTypeFullName = x.ConstructorArguments[0].ValueTypeFullName,
                ToTypeSyntax = compilation.GetAllTypes()
                    .First(t => t.TypeFullName == x.ConstructorArguments[0].ValueTypeFullName).SyntaxNode
            });
    }

    IEnumerable<AttributeSyntax> GetAttributes(ClassDeclarationSyntax classDecl)
    {
        return classDecl.AttributeLists.SelectMany(list => list.Attributes);
    }

    string GetAttributeFullName(AttributeSyntax attribute)
    {
        return attribute.Name.GetText().ToString();
    }
}

public class ClassSyntaxReceiver : ISyntaxReceiver
{
    public List<AutoMappingMetadata> AutoMappingMetadataList { get; set; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not ClassDeclarationSyntax cds)
        {
            return;
        }

        var attributeSyntax = cds.AttributeLists
            .SelectMany(x => x.Attributes)
            .FirstOrDefault(attr => attr.Name.ToString() == "AutoMapping");
        if (attributeSyntax == null)
        {
            return;
        }

        var attributeArguments = attributeSyntax.ArgumentList!.Arguments;
        var fromTypeClassName = attributeArguments.First().GetTypeofClassName();
        var toTypeClassName = attributeArguments.ElementAt(1).GetTypeofClassName();
        var className = cds.Identifier.Text;

        // cds.Members.Select(x => x as PropertyDeclarationSyntax)
        //     .Where(x => x != null)
        //     .Select(x => x!.Identifier.Text)
        //     .ToList();
        AutoMappingMetadataList.Add(new AutoMappingMetadata
        {
            FromTypeName = fromTypeClassName,
            ToTypeName = toTypeClassName,
            ClassName = className,
        });
    }
}

public class AutoMappingMetadata
{
    public string FromTypeName { get; set; } = null!;
    public string ToTypeName { get; set; } = null!;
    public string ClassName { get; set; } = null!;
}