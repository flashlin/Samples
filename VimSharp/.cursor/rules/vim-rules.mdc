---
description: VimSharp Rules
globs: *.cs
alwaysApply: false
---
## Rule 1: Default color configuration
- Set the default foreground color to white.
- Set the default background color to DarkGray for ColoredChar instances.

## Rule 2: Handle ASCII characters with specific length
- If Chars[n].Char has an ASCII length of 2, ensure that the next character is '\0'.

## Rule 3: Automatic handling of multi-byte characters
- If setting Chars[n].Char to a character like 'ä¸­' that exceeds 2 bytes, automatically set Chars[n+1].Char to '\0'.

## Rule 4: Handle left/up/down cursor movement
- When the cursor moves left, up, or down to position n, if Chars[n].Char is '\0', move further left or up/down until a non-'\0' character is found.

## Rule 5: Handle right cursor movement
- When the cursor moves right to position n, if Chars[n].Char is '\0', continue moving right until a non-'\0' character is encountered.

## Rule 6: Simplified Switch Case Statements
- Ensure each case statement within a switch only calls one method followed by a break.
- Extract logic from lengthy case statements into distinct methods.

## Rule 6: Simplify VimNormalMode
- Exclude private bool _continueEditing = true; from VimNormalMode.
- Allow VimEditor to independently handle looping through WaitForInput.

## Rule 8: Control Rendering in Vim Modes
- In VimVisualMode::WaitForInput() and VimNormalMode::WaitForInput(), refrain from calling Instance.Render() at the conclusion.
- Delegate rendering control to VimEditor.

## Rule 9: Uniform Cursor Style Settings
- Apply cursor styling using Console.Write("\x1b[6 q"); for a vertical line cursor consistently across all platforms.
- Apply cursor styling using Console.Write("\x1b[2 q"); for a block cursor consistently across all platforms.
- No platform-specific conditional checks are needed for cursor styling.

## Rule 10: Cursor Movement and End Detection in Vim Modes

- **VimVisualMode:**
  - When moving the cursor, determine if it is at the end by checking if it's simply at the end of the text.

- **VimNormalMode:**
  - When moving the cursor, determine if it is at the end by checking if it's on the last character of the text.

## Rule 11: Cursor Positioning at End of Document
- When the cursor reaches the end of the document, keep it positioned on the last character, not merely beyond the text's end.


## Rule 12: Cursor Visibility in Render
- At the start of VimEditor::Render(), use ASCII codes to set the cursor as invisible.
- After completing the render process, ensure the cursor is made visible again.


## Rule 13: Preserve Existing Test Code
- Prohibit modifications to existing test code.
- Only allow changes if explicitly requested by the user.


## Rule 14: Approach for Test Failures
- When a test fails, prioritize modifying the code logic to meet test acceptance criteria.
- Do not modify the acceptance results of tests unless specifically instructed by the user.


## Rule 15: Avoid Hardcoding in Code Modifications
- When adjusting application logic to meet test acceptance criteria, refrain from using hardcoded values or solutions.
- Ensure that code changes promote flexibility, maintainability, and adherence to best practices.


rules:
  - description: Replace 'new[] { }' syntax with the '[]' syntax
    find: 'new[] { $KEYS$ }'
    replace: '[$KEYS$]'
    file_globs:
      - "**/*.cs"  # Assuming you're working with C# files

  - name: Get Text Width Logic
    - Use the ConsoleText::Width method to obtain the length of any text line.
    - Do not calculate the length manually or use any other methods.

  - name: RelativeLineNumerWidth Logic
    instructions: |
      Configure Vim to adjust the relative line number area width to match the number of digits in the total number of lines, with an added spacing of 1.

  - name: DirectCursorUse
    targets:
      - methods: 
          - VimEditor::Render
    instructions: >
      Always use Content.CursorX and Content.CursorY directly for cursor positions in VimEditor::Render.
      Do not compute logic in this function.

# Rule for calculating logic before setting cursor position
  - name: PreCalculateCursorLogic
    targets:
      - variables:
          - CursorX
          - CursorY
    instructions: >
      Application logic should calculate and set values for CursorX and CursorY as needed before rendering.

  - name: ControlCursorPosition
    targets:
      - variables:
          - Context.CursorX
          - Context.CursorY
    instructions: >
      Use Context.CursorX and Context.CursorY to control the cursor's position on the screen.
      Ensure all cursor movements and placements strictly use these Context variables.

# Rule for using Context.OffsetX and Context.OffsetY
  - name: TextBlockDisplayPosition
    targets:
      - variables:
          - Context.OffsetX
          - Context.OffsetY
    instructions: >
      Use Context.OffsetX and Context.OffsetY to set the starting display position for text blocks (Texts).
      Ensure the display logic adheres to these offset values.

# Rule for defining Context.ViewPort
  - name: DefineVisibleRange
    targets:
      - variables:
          - Context.ViewPort
    instructions: >
      Context.ViewPort should define the visible range, including the screen's coordinate position, width, and height.
      Specify all rendering within these constraints.


# SetCursorPositionAndAdjustViewport(int textX,int textY) 
The function SetCursorPositionAndAdjustViewport(int textX, int textY) in [VimEditor.cs](mdc:VimSharpLib/VimEditor.cs) is responsible for positioning the cursor at the desired coordinates within Texts. It then adjusts the CursorX and CursorY coordinates displayed on the screen accordingly, while also modifying OffsetX and OffsetY to determine the starting display position of Texts.

