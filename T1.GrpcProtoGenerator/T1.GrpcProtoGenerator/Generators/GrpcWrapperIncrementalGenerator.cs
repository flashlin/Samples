using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace T1.GrpcProtoGenerator.Generators
{
    [Generator]
    public class GrpcWrapperIncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var protoFiles = context.AdditionalTextsProvider
                .Where(f => f.Path.EndsWith(".proto"));

            var protoFilesWithContent = protoFiles.Select((text, _) => new ProtoFileInfo
            {
                Path = text.Path,
                Content = text.GetText()!.ToString()
            });

            context.RegisterSourceOutput(protoFilesWithContent, (spc, protoInfo) =>
            {
                var model = ProtoParser.ParseProtoText(protoInfo.Content);
                var source = GenerateWrapperSource(model);
                
                // Extract proto file name without extension for better file naming
                var protoFileName = protoInfo.GetProtoFileName();
                var fileName = $"Generated_{protoFileName}.cs";
                
                spc.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
            });
        }

        private string GenerateWrapperSource(ProtoModel model)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// This file was generated by T1.GrpcProtoGenerator");
            sb.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using Grpc.Core;");
            sb.AppendLine("using Microsoft.Extensions.Logging;");
            sb.AppendLine();
            
            // Use a different namespace to avoid conflicts with built-in gRPC generator
            var targetNamespace = !string.IsNullOrEmpty(model.CsharpNamespace) ? $"{model.CsharpNamespace}.Generated" : "Generated";
            sb.AppendLine($"namespace {targetNamespace}");
            sb.AppendLine("{");

            // DTOs
            foreach (var msg in model.Messages)
            {
                sb.AppendLine($"public class {msg.Name}Dto {{");
                foreach (var f in msg.Fields)
                {
                    var csType = f.IsRepeated ? $"List<{f.Type}>" : f.Type;
                    sb.AppendLine($"    public {csType} {char.ToUpper(f.Name[0]) + f.Name.Substring(1)} {{ get; set; }}");
                }
                sb.AppendLine("}");
            }

            // Enums
            foreach (var e in model.Enums)
            {
                sb.AppendLine($"public enum {e.Name} {{");
                foreach (var val in e.Values)
                    sb.AppendLine($"    {val.Name} = {val.Value},");
                sb.AppendLine("}");
            }

            // Service interfaces and implementations
            foreach (var svc in model.Services)
            {
                var originalNamespace = !string.IsNullOrEmpty(model.CsharpNamespace) ? model.CsharpNamespace : "Generated";
                
                // Generate service interface (IxxxGrpcService)
                var serviceInterface = $"I{svc.Name}GrpcService";
                sb.AppendLine($"public interface {serviceInterface} {{");
                foreach (var rpc in svc.Rpcs)
                {
                    sb.AppendLine($"    Task<{originalNamespace}.{rpc.ResponseType}> {rpc.Name}({originalNamespace}.{rpc.RequestType} request, ServerCallContext context);");
                }
                sb.AppendLine("}");
                sb.AppendLine();

                // Generate service implementation (xxxService : xxx.xxxBase)
                var serviceClass = $"{svc.Name}Service";
                var baseClass = $"{originalNamespace}.{svc.Name}.{svc.Name}Base";
                sb.AppendLine($"public class {serviceClass} : {baseClass} {{");
                sb.AppendLine($"    private readonly {serviceInterface} _instance;");
                sb.AppendLine();
                sb.AppendLine($"    public {serviceClass}({serviceInterface} instance)");
                sb.AppendLine($"    {{");
                sb.AppendLine($"        _instance = instance;");
                sb.AppendLine($"    }}");
                sb.AppendLine();

                foreach (var rpc in svc.Rpcs)
                {
                    sb.AppendLine($"    public override Task<{originalNamespace}.{rpc.ResponseType}> {rpc.Name}({originalNamespace}.{rpc.RequestType} request, ServerCallContext context)");
                    sb.AppendLine($"    {{");
                    sb.AppendLine($"        return _instance.{rpc.Name}(request, context);");
                    sb.AppendLine($"    }}");
                    sb.AppendLine();
                }
                sb.AppendLine("}");
                sb.AppendLine();
                
                // Generate client interface and wrapper for completeness
                var clientInterface = $"I{svc.Name}Client";
                sb.AppendLine($"public interface {clientInterface} {{");
                foreach (var rpc in svc.Rpcs)
                    sb.AppendLine($"    Task<{rpc.ResponseType}Dto> {rpc.Name}Async({rpc.RequestType}Dto request, CancellationToken cancellationToken = default);");
                sb.AppendLine("}");
                sb.AppendLine();

                var wrapper = $"{svc.Name}ClientWrapper";
                var grpcClient = $"{originalNamespace}.{svc.Name}.{svc.Name}Client";
                sb.AppendLine($"public class {wrapper} : {clientInterface} {{");
                sb.AppendLine($"    private readonly {grpcClient} _inner;");
                sb.AppendLine($"    public {wrapper}({grpcClient} inner) {{ _inner = inner; }}");
                sb.AppendLine();

                foreach (var rpc in svc.Rpcs)
                {
                    sb.AppendLine($"    public async Task<{rpc.ResponseType}Dto> {rpc.Name}Async({rpc.RequestType}Dto request, CancellationToken cancellationToken = default) {{");
                    sb.AppendLine($"        var grpcReq = new {originalNamespace}.{rpc.RequestType}();");
                    sb.AppendLine($"        // TODO: Map from DTO to gRPC request");
                    sb.AppendLine($"        var grpcResp = await _inner.{rpc.Name}Async(grpcReq, cancellationToken: cancellationToken);");
                    sb.AppendLine($"        var dto = new {rpc.ResponseType}Dto();");
                    sb.AppendLine($"        // TODO: Map from gRPC response to DTO");
                    sb.AppendLine($"        return dto;");
                    sb.AppendLine($"    }}");
                    sb.AppendLine();
                }
                sb.AppendLine("}");
            }

            sb.AppendLine("}");
            return sb.ToString();
        }
    }

    public class ProtoFileInfo
    {
        public string Path { get; set; }
        public string Content { get; set; }

        public string GetProtoFileName()
        {
            return System.IO.Path.GetFileNameWithoutExtension(Path);
        }
    }
}
