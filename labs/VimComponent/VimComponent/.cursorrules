# Project Context
This is a Web Component library project built with TypeScript.

## Pre-requisites Before Handling User Requests
Before processing any user request, you must:
1. Scan the current project structure
2. Understand the project content and architecture
3. Then proceed with the user's request

## Code Style Guidelines

### Method Length
- Keep method content short and focused
- Extract code blocks into smaller methods based on functionality
- Each method should have a single, clear responsibility

### Comments
- Do not write comments in the code
- Code should be self-documenting through clear naming and structure

## TypeScript Standards
- Use camelCase for interface properties
- Follow TypeScript best practices for Web Component development

## Key Mapping Implementation Guidelines

### Priority: Use commandPatterns
When adding any key mapping functionality:
1. **First Priority**: Use the `commandPatterns` array with pattern-based approach
   - Add new patterns to the `commandPatterns` array
   - Define the key sequence as a pattern string
   - Implement the action as a callback function
   - This approach is preferred for its simplicity and maintainability

2. **Alternative Approach**: Only implement custom logic when:
   - The pattern-based approach cannot handle the requirement
   - Complex state management is needed beyond simple pattern matching
   - Special handling is required that doesn't fit the pattern model

### Example
```typescript
// Good: Using commandPatterns
{ pattern: 'gg', action: () => { this.moveToFirstLine(); } }

// Only when necessary: Custom implementation
if (this.keyBuffer === 'special' && needsComplexLogic) {
  // custom handling
}
```

## Testing Guidelines

### CRITICAL: Test-Driven Development Workflow
When adding or modifying any functionality, you MUST follow this workflow:

1. **After Implementation**: Run tests immediately
   ```bash
   npm test -- --run
   ```
   - Ensure all existing tests still pass
   - Verify that new/modified functionality doesn't break existing features
   - If any tests fail, fix the implementation before proceeding

2. **Add Test Cases**: Write comprehensive test cases for the new functionality
   - Cover normal use cases
   - Cover edge cases and error conditions
   - Cover interaction with existing features
   - Test both forward and backward operations (if applicable)
   - Test with various input types (English, Chinese, special characters, etc.)

3. **Final Verification**: Run all tests again
   ```bash
   npm test -- --run
   ```
   - Ensure all tests pass (both old and new)
   - Verify test coverage is adequate
   - Only consider the task complete when all tests are green

### Test Case Requirements
- Place test cases in the `tests/` directory
- Follow existing test patterns and naming conventions
- Use descriptive test names that explain what is being tested
- Group related tests using `describe` blocks
- Each test should be independent and isolated

### Example Test Workflow
```typescript
// 1. Implement feature
{ pattern: '%', action: () => { this.jumpToMatchingBracket(); } }

// 2. Run existing tests
// npm test -- --run

// 3. Add test cases
describe('% command (jump to matching bracket)', () => {
  it('should jump from opening bracket to closing bracket', async () => {
    // test implementation
  });
  
  it('should handle nested brackets', async () => {
    // test implementation
  });
  
  it('should handle escaped characters', async () => {
    // test implementation
  });
});

// 4. Run all tests again
// npm test -- --run
```

### Why This Matters
- Prevents regression bugs
- Ensures code quality and reliability
- Documents expected behavior
- Makes future refactoring safer
- Provides confidence in changes

**⚠️ WARNING**: Do NOT consider any feature implementation complete until:
1. All existing tests pass
2. New test cases are written
3. All tests (old + new) pass successfully

